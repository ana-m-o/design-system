#!/usr/bin/env node

const exec = require('child_process').exec;
const fs = require('fs');

// The third argument is a temporal file where to read/write the commit message
const output_file = process.argv[2]


function commitIsPrefixed(commit){
    // Check if the commit is already prefixed
    // This can happen when the branch is rebased or the commit is amended
    const regex = /^(\[\w+-\d+\])/;
    const match = commit.match(regex);
    return !!match;
}

function getIssue(branch){
    // Use RegExp to get the issue from the branch
    // Exam: bugfix/CIA-638_kill_castro_yeah_again match to CIA-638
    const regex = /^(\w+)\/(\w+-\d+)/g;
    const match = branch.match(regex);
    return match ? match[0].match(/(\w+-\d+)$/)[0] : undefined;
}

// Get actual name of branch
exec('git symbolic-ref --short HEAD', (error, branch) => {
    if(error) process.exit(-1);

    const issue = getIssue(branch);
    if(!issue) {
        // Exit, maybe the branch is master|develop|staging
        process.exit(0);
    }

    // Read the temp file to get the actual commit message
    fs.readFile(output_file, 'utf8', (err, commit) => {
        if(err) {
            console.error('Error reading the commit message');
            process.exit(-1)
        }

        if(commitIsPrefixed(commit)){
            // If the commit is already prefixed, exit
            process.exit(0)
        }

        // Write to the temp file the commit message prefixed with the issue
        fs.writeFile(output_file, `[${issue}] ${commit}`, 'utf8', err => {
            if(err) {
                console.error('Error writing the commit message');
                process.exit(-1)
            }
        })
    })
});
